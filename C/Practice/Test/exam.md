一
1. scanf("%lf",&x);
2. (year%4==0&&year%100!=0)||(year%400==0)
3. 9 (这个题 题目有误，前面是ab 后面是xy，如果x对应a、 y对应b则答案为9；反之也为9)
4. ch = n ? '*' : '#';
5. a=5 b=7
6. strcmp(str[2],str[0])>0;
7. b=5 c=12
8. max(max(a, b), c)
9. stu1.birthday.year=2002;
10. fseek(fp, -10, SEEK_END);

二
1. 
 *******
  *****
   ***
    *

2.
Case 1: 1 7 2 
Case 2: 1 4 3 2 
Case 3: 1 4 5 
Case 4: 7 3 
Case 5: 3 5 2 
Total: 5

分析：寻找数组a中所有和为v的组合，这些组合的元素可以不连续。对于数组a中的每个元素，你的代码都会检查是否可以将其包含在一个组合中（即，是否可以从v中减去该元素）。如果可以，就将该元素标记为已选（mk[i]=1），并递归地调用load函数处理剩余的元素和剩余的值（v-a[i]）。如果不可以，就将该元素标记为未选（mk[i]=0）。
当v减到0时，就找到了一个有效的组合，此时会调用print函数打印出这个组合，并增加计数器count。

3.
输入0时
11 12 13 14 15 
16 17 18 19 20 
21 22 23 24 25 

输入3时
15 20 25 
14 19 24 
13 18 23 
12 17 22 
11 16 21 

三
1. >=
2. top+bot
3. mid
4. top
5. k+1

四
1.
